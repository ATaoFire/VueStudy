<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>计算属性</title>
    <script src="vue.js" type="text/javascript" charset="utf-8"></script> 
</head>
<body>
    <!-- 计算属性 -->

    <!-- 
        模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。
        在模板中放入太多的逻辑会让模板过重且难以维护
     -->
    <div id="example">
        <!-- 这模板比较复杂,需要查看几次才可以看出具体内容,复杂的都应该使用计算属性 -->
        {{ message.split('').reverse().join('') }}

        <!-- 例子 -->
        <p>正常输出: "{{ message }}"</p>
        <p>计算反转后输出: "{{ reversedMessage }}"</p>

        <!-- 调用方法 -->
        <!-- 
            同一函数定义为一个方法而不是一个计算属性。
            两种方式的最终结果确实是完全相同的。
            然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。
            只在相关响应式依赖发生改变时它们才会重新求值。
            这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 
            计算属性会立即返回之前的计算结果，而不必再次执行函数 
        -->
        <p>Reversed message: "{{ reversedMessage1() }}"</p>

        <p>{{now}}</p>
    </div>
    <script type="text/javascript">
        var vm = new Vue({
            el:"#example",
            data:{
                message: 'Hello',
            },
            computed: {
                // 计算属性的getter方法
                //reversedMessage 声明的计算属性,我们提供的函数将用作 property vm.reversedMessage 的 getter 函数
                //绑定属性,只有message发生变化时,reversedmessage才会发生变化
                reversedMessage: function(){
                    // `this` 指向 vm 实例
                    return this.message.split('').reverse().join('')
                },
                now: function () {
                    return Date.now() //不是响应式依赖
                },
            },
            methods: {
                reversedMessage1: function () {
                    return this.message.split('').reverse().join('')
                }
            },
        })
    </script>
</body>
</html>